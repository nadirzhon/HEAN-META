<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transcendent Entity</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #000000;
            color: #ffffff;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        /* Noise texture background */
        #noise-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.15;
            z-index: 0;
            pointer-events: none;
        }

        /* Canvas for Three.js */
        #singularity-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* Floating translucent panels */
        .panel {
            position: fixed;
            background: rgba(20, 20, 30, 0.6);
            backdrop-filter: blur(10px);
            border: none;
            padding: 20px;
            z-index: 10;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .panel h2 {
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: #888;
            margin-bottom: 15px;
            font-weight: normal;
        }

        .panel .value {
            font-size: 28px;
            color: #fff;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .panel .label {
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Top-left: Extraction Capacity */
        #balance-panel {
            top: 30px;
            left: 30px;
            min-width: 200px;
        }

        /* Top-right: Real-time Extraction Delta */
        #pnl-panel {
            top: 30px;
            right: 30px;
            min-width: 200px;
        }

        .pnl-positive {
            color: #00ff88 !important;
        }

        .pnl-negative {
            color: #ff3366 !important;
        }

        /* Bottom-left: Logic State */
        #state-panel {
            bottom: 30px;
            left: 30px;
            min-width: 250px;
        }

        .state-value {
            font-size: 16px;
            color: #00ff88;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Right side: Thought Stream (Causal Mesh) */
        #causal-mesh-panel {
            top: 30px;
            right: 30px;
            bottom: 30px;
            width: 450px;
            height: calc(100vh - 60px);
            overflow: hidden;
        }

        #causal-mesh-canvas {
            width: 100%;
            height: calc(100% - 60px);
            cursor: move;
        }

        /* Connection status */
        #connection-status {
            position: fixed;
            bottom: 30px;
            right: 30px;
            z-index: 20;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #connection-status.connected {
            color: #00ff88;
        }

        #connection-status.disconnected {
            color: #ff3366;
        }

        /* Loading overlay */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            font-size: 18px;
            color: #888;
        }
    </style>
</head>
<body>
    <!-- Noise texture canvas -->
    <canvas id="noise-canvas"></canvas>

    <!-- Three.js canvas for Singularity -->
    <canvas id="singularity-canvas"></canvas>

    <!-- Floating panels -->
    <div class="panel" id="balance-panel">
        <h2>Extraction Capacity</h2>
        <div class="value" id="balance-value">$300.00</div>
        <div class="label">USDT</div>
    </div>

    <div class="panel" id="pnl-panel">
        <h2>Extraction Delta</h2>
        <div class="value" id="pnl-value">$0.00</div>
        <div class="label">Real-time</div>
    </div>

    <div class="panel" id="state-panel">
        <h2>Logic State</h2>
        <div class="state-value" id="state-value">INITIALIZING</div>
    </div>

    <div class="panel" id="causal-mesh-panel">
        <h2>Thought Stream</h2>
        <canvas id="causal-mesh-canvas"></canvas>
    </div>

    <div id="connection-status" class="disconnected">Disconnected</div>

    <div id="loading">Initializing Transcendent Entity...</div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // Global state
        let singularityScene, singularityCamera, singularityRenderer;
        let singularityObject, singularityGlow;
        let volatility = 0.5;
        let confidence = 0.7;
        
        let causalMeshNodes = [];
        let causalMeshEdges = [];
        let causalMeshSimulation;
        let causalMeshCanvas, causalMeshCtx;
        let ws = null;
        let isConnected = false;

        // Initialize noise texture
        function initNoiseTexture() {
            const canvas = document.getElementById('noise-canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                const value = Math.random() * 255;
                data[i] = value;     // R
                data[i + 1] = value; // G
                data[i + 2] = value; // B
                data[i + 3] = 255;   // A
            }

            ctx.putImageData(imageData, 0, 0);

            // Update on resize
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                // Re-generate noise
                initNoiseTexture();
            });
        }

        // Initialize Three.js Singularity
        function initSingularity() {
            const canvas = document.getElementById('singularity-canvas');
            const width = window.innerWidth;
            const height = window.innerHeight;

            // Scene
            singularityScene = new THREE.Scene();
            singularityScene.background = null; // Transparent

            // Camera
            singularityCamera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            singularityCamera.position.z = 5;

            // Renderer
            singularityRenderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                antialias: true,
                alpha: true 
            });
            singularityRenderer.setSize(width, height);
            singularityRenderer.setPixelRatio(window.devicePixelRatio);

            // Singularity object (icosahedron with glow)
            const geometry = new THREE.IcosahedronGeometry(1, 1);
            
            // Main material with glow
            const material = new THREE.MeshStandardMaterial({
                color: 0x00ff88,
                emissive: 0x004422,
                metalness: 0.8,
                roughness: 0.2,
                transparent: true,
                opacity: 0.9
            });
            
            singularityObject = new THREE.Mesh(geometry, material);
            singularityScene.add(singularityObject);

            // Glow effect (outline)
            const glowGeometry = new THREE.IcosahedronGeometry(1.1, 1);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff88,
                transparent: true,
                opacity: 0.3,
                side: THREE.BackSide
            });
            singularityGlow = new THREE.Mesh(glowGeometry, glowMaterial);
            singularityScene.add(singularityGlow);

            // Ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            singularityScene.add(ambientLight);

            // Point light
            const pointLight = new THREE.PointLight(0x00ff88, 1, 100);
            pointLight.position.set(5, 5, 5);
            singularityScene.add(pointLight);

            // Handle resize
            window.addEventListener('resize', () => {
                const width = window.innerWidth;
                const height = window.innerHeight;
                singularityCamera.aspect = width / height;
                singularityCamera.updateProjectionMatrix();
                singularityRenderer.setSize(width, height);
            });

            // Start animation
            animateSingularity();
        }

        // Animate Singularity (pulse speed = volatility, glow = confidence)
        function animateSingularity() {
            requestAnimationFrame(animateSingularity);

            const time = Date.now() * 0.001;
            const pulseSpeed = volatility * 2.0 + 0.5; // Pulse speed correlates with volatility
            const pulseScale = 1.0 + Math.sin(time * pulseSpeed) * 0.1;
            
            singularityObject.scale.set(pulseScale, pulseScale, pulseScale);
            singularityObject.rotation.x += 0.005;
            singularityObject.rotation.y += 0.01;

            // Glow intensity correlates with confidence
            const glowIntensity = confidence;
            singularityGlow.scale.set(pulseScale * 1.1, pulseScale * 1.1, pulseScale * 1.1);
            singularityGlow.material.opacity = 0.1 + glowIntensity * 0.4;
            
            // Update material emissive based on confidence
            const emissiveIntensity = confidence * 0.5;
            singularityObject.material.emissive.setRGB(
                emissiveIntensity * 0.1,
                emissiveIntensity * 0.5,
                emissiveIntensity * 0.3
            );

            singularityRenderer.render(singularityScene, singularityCamera);
        }

        // Initialize Causal Mesh force-directed graph
        function initCausalMesh() {
            causalMeshCanvas = document.getElementById('causal-mesh-canvas');
            causalMeshCtx = causalMeshCanvas.getContext('2d');
            
            const rect = causalMeshCanvas.parentElement.getBoundingClientRect();
            causalMeshCanvas.width = rect.width;
            causalMeshCanvas.height = rect.height - 60;

            // Simple force-directed simulation
            causalMeshSimulation = {
                nodes: [],
                edges: [],
                width: causalMeshCanvas.width,
                height: causalMeshCanvas.height,
                charge: -300,
                linkDistance: 100,
                alpha: 1.0,
                alphaDecay: 0.02
            };

            // Handle resize
            window.addEventListener('resize', () => {
                const rect = causalMeshCanvas.parentElement.getBoundingClientRect();
                causalMeshCanvas.width = rect.width;
                causalMeshCanvas.height = rect.height - 60;
                causalMeshSimulation.width = causalMeshCanvas.width;
                causalMeshSimulation.height = causalMeshCanvas.height;
            });

            // Start animation
            animateCausalMesh();
        }

        // Simple force-directed graph simulation
        function tickSimulation() {
            const nodes = causalMeshSimulation.nodes;
            const edges = causalMeshSimulation.edges;
            const k = Math.sqrt((causalMeshSimulation.width * causalMeshSimulation.height) / nodes.length);
            const charge = causalMeshSimulation.charge;
            const linkDistance = causalMeshSimulation.linkDistance;

            // Repulsion forces
            for (let i = 0; i < nodes.length; i++) {
                let fx = 0, fy = 0;
                for (let j = 0; j < nodes.length; j++) {
                    if (i === j) continue;
                    const dx = nodes[i].x - nodes[j].x;
                    const dy = nodes[i].y - nodes[j].y;
                    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                    const force = charge * k / (dist * dist);
                    fx += (dx / dist) * force;
                    fy += (dy / dist) * force;
                }
                nodes[i].vx = (nodes[i].vx || 0) * 0.6 + fx * 0.1;
                nodes[i].vy = (nodes[i].vy || 0) * 0.6 + fy * 0.1;
            }

            // Link forces
            for (const edge of edges) {
                const source = edge.source;
                const target = edge.target;
                const dx = target.x - source.x;
                const dy = target.y - source.y;
                const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                const strength = (linkDistance - dist) / dist * 0.3;
                const fx = dx * strength;
                const fy = dy * strength;
                source.vx = (source.vx || 0) + fx;
                source.vy = (source.vy || 0) + fy;
                target.vx = (target.vx || 0) - fx;
                target.vy = (target.vy || 0) - fy;
            }

            // Update positions
            for (const node of nodes) {
                node.x += node.vx || 0;
                node.y += node.vy || 0;
                node.x = Math.max(20, Math.min(causalMeshSimulation.width - 20, node.x));
                node.y = Math.max(20, Math.min(causalMeshSimulation.height - 20, node.y));
                node.vx *= 0.8;
                node.vy *= 0.8;
            }

            causalMeshSimulation.alpha *= (1 - causalMeshSimulation.alphaDecay);
        }

        // Render Causal Mesh
        function renderCausalMesh() {
            const ctx = causalMeshCtx;
            ctx.clearRect(0, 0, causalMeshCanvas.width, causalMeshCanvas.height);

            // Draw edges
            ctx.strokeStyle = 'rgba(0, 255, 136, 0.3)';
            ctx.lineWidth = 1;
            for (const edge of causalMeshSimulation.edges) {
                ctx.globalAlpha = edge.strength || 0.5;
                ctx.beginPath();
                ctx.moveTo(edge.source.x, edge.source.y);
                ctx.lineTo(edge.target.x, edge.target.y);
                ctx.stroke();
            }

            // Draw nodes
            ctx.globalAlpha = 1.0;
            for (const node of causalMeshSimulation.nodes) {
                // Node circle
                ctx.fillStyle = '#00ff88';
                ctx.beginPath();
                ctx.arc(node.x, node.y, 4, 0, Math.PI * 2);
                ctx.fill();

                // Node label
                ctx.fillStyle = '#888';
                ctx.font = '10px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(node.symbol || 'N', node.x, node.y - 10);
            }
        }

        // Animate Causal Mesh
        function animateCausalMesh() {
            requestAnimationFrame(animateCausalMesh);
            
            if (causalMeshSimulation.alpha > 0.01) {
                for (let i = 0; i < 5; i++) {
                    tickSimulation();
                }
            }
            
            renderCausalMesh();
        }

        // Update Causal Mesh data
        function updateCausalMesh(nodes, edges) {
            // Convert to simulation format
            causalMeshSimulation.nodes = nodes.map((n, i) => ({
                symbol: n.symbol || `N${i}`,
                x: n.x || (Math.random() * causalMeshSimulation.width),
                y: n.y || (Math.random() * causalMeshSimulation.height),
                vx: 0,
                vy: 0
            }));

            // Find node indices for edges
            causalMeshSimulation.edges = edges.map(e => {
                const sourceIdx = causalMeshSimulation.nodes.findIndex(n => n.symbol === e.source);
                const targetIdx = causalMeshSimulation.nodes.findIndex(n => n.symbol === e.target);
                if (sourceIdx >= 0 && targetIdx >= 0) {
                    return {
                        source: causalMeshSimulation.nodes[sourceIdx],
                        target: causalMeshSimulation.nodes[targetIdx],
                        strength: e.strength || 0.5
                    };
                }
                return null;
            }).filter(e => e !== null);

            causalMeshSimulation.alpha = 1.0; // Restart simulation
        }

        // WebSocket connection
        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws`;
            
            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                isConnected = true;
                updateConnectionStatus(true);
                document.getElementById('loading').style.display = 'none';
            };

            ws.onmessage = (event) => {
                // Handle JSON message
                try {
                    const data = JSON.parse(event.data);
                    updateUI(data);
                } catch (e) {
                    console.error('Error parsing WebSocket message:', e);
                }
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                updateConnectionStatus(false);
            };

            ws.onclose = () => {
                isConnected = false;
                updateConnectionStatus(false);
                // Reconnect after 3 seconds
                setTimeout(connectWebSocket, 3000);
            };
        }

        // Update UI with data
        function updateUI(data) {
            if (data.balance !== undefined) {
                document.getElementById('balance-value').textContent = '$' + data.balance.toFixed(2);
            }
            
            if (data.pnl !== undefined) {
                const pnlEl = document.getElementById('pnl-value');
                pnlEl.textContent = (data.pnl >= 0 ? '+' : '') + '$' + data.pnl.toFixed(2);
                pnlEl.className = 'value ' + (data.pnl >= 0 ? 'pnl-positive' : 'pnl-negative');
            }
            
            if (data.logic_state !== undefined) {
                document.getElementById('state-value').textContent = data.logic_state;
            }
            
            if (data.volatility !== undefined) {
                volatility = Math.max(0, Math.min(1, data.volatility));
            }
            
            if (data.confidence !== undefined) {
                confidence = Math.max(0, Math.min(1, data.confidence));
            }
            
            if (data.nodes && data.edges) {
                updateCausalMesh(data.nodes, data.edges);
            }
        }

        // Update connection status
        function updateConnectionStatus(connected) {
            const statusEl = document.getElementById('connection-status');
            statusEl.textContent = connected ? 'Connected' : 'Disconnected';
            statusEl.className = connected ? 'connected' : 'disconnected';
        }

        // Initialize everything
        function init() {
            initNoiseTexture();
            initSingularity();
            initCausalMesh();
            connectWebSocket();
        }

        // Start when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
